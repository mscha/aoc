#!/usr/bin/env raku
use v6.d;
$*OUT.out-buffer = False;   # Autoflush

# Advent of Code 2021 day 14 -- https://adventofcode.com/2021/day/14

grammar PolymerSpecs
{
    rule TOP { <template> <insertion>+ }

    token template { <element>+ }
    rule insertion { <pair> '->' <element> }

    token pair { <element><element> }
    token element { <[A..Z]> }
}

class Polymer
{
    has Str $.specs is required;

    has Int %.pairs;
    has Str %.rules;
    has Int %.frequencies;

    submethod TWEAK
    {
        PolymerSpecs.parse($!specs, :actions(self))
            or die "Unable to parse specifications!";
    }

    method template($/) {
        my @elems = $/.comb;
        %!frequencies{@elems}Â»++;
        %!pairs = bag @elems Z~ @elems[1..*];
    }

    method insertion($/)
    {
        %!rules{$<pair>} = ~$<element>;
    }

    method grow
    {
        # Each pair is replaced by two pairs, following the appropriate rule.
        my %new-pairs;
        for %!pairs -> $p {
            my ($a, $b) = $p.key.comb;
            my $ins = %!rules{$p.key};
            %!frequencies{$ins} += $p.value;
            %new-pairs{$a ~ $ins} += $p.value;
            %new-pairs{$ins ~ $b} += $p.value;
        }
        %!pairs = %new-pairs;
    }

    method length { %!pairs.values.sum + 1 }

    method strength { [R-] self.frequencies.values.minmax.bounds }
}

sub MAIN(IO() $inputfile where *.f = 'aoc14.input', Bool :v(:$verbose) = False)
{
    my $poly = Polymer.new(:specs($inputfile.slurp));
    say "Initial length: ", $poly.length if $verbose;

    for 1..10 -> $step {
        $poly.grow;
        say "After step $step: length ", $poly.length if $verbose;
    }
    say "Part 1: ", $poly.strength;

    for 11..40 -> $step {
        $poly.grow;
        say "After step $step: length ", $poly.length if $verbose;
    }
    say "Part 2: ", $poly.strength;
}
