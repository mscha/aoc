#!/usr/bin/env perl6
use v6.d;

# Advent of Code 2019 day 14 -- https://adventofcode.com/2019/day/14

$*OUT.out-buffer = False;   # Autoflush

grammar Reaction
{
    rule TOP { [ <count-in> <elem-in> ]+ % ',' '=>' <count-out> <elem-out> }

    token count-in { \d+}
    token count-out { \d+}

    token elem-in { <alpha>+ }
    token elem-out { <alpha>+ }
}

class NanoFactory
{
    has Str @.reactions;
    has %.input;
    has %.output;

    has Bool $.verbose = False;
    has Int $!verbose-indent = 1;

    has Int %.stock is default(0);
    has Int $.ore-consumed = 0;

    submethod TWEAK
    {
        if !%!input && @!reactions {
            for @!reactions -> $r {
                my $ingredients = Reaction.parse($r) or die "Invalid reaction: $r";
                my $elem-out = ~$ingredients<elem-out>;
                my $count-out = +$ingredients<count-out>;
                for $ingredients<elem-in> Z $ingredients<count-in> -> ($e, $c) {
                    %!input{$elem-out}{$e} = +$c;
                    %!output{$elem-out} = $count-out;
                }
            }
        }
    }

    method reset
    {
        %!stock = Empty;
        $!ore-consumed = 0;
    }

    method produce(Str $elem, Int $count)
    {
        self.log("[Requested: $count $elem; stock is %!stock{$elem}]");

        my $to-produce = $count - %!stock{$elem};
        return if $to-produce ≤ 0;

        my $units = ceiling($to-produce / %!output{$elem});
        for %!input{$elem}.kv -> $e, $c {
            temp $!verbose-indent; $!verbose-indent++;
            self.consume($e, $units × $c);
        }

        my $produced = $units × %!output{$elem};
        %!stock{$elem} += $produced;
        self.log("[Produced: $produced $elem; stock is %!stock{$elem}]");
    }

    multi method consume(Str $elem, Int $count)
    {
        if $elem eq 'ORE' {
            $!ore-consumed += $count;
            self.log("[Consumed: $count ORE; total ORE consumption is $!ore-consumed]");
        }
        else {
            self.produce($elem, $count);
            %!stock{$elem} -= $count;
            self.log("[Consumed $count $elem; stock is %!stock{$elem}]");
        }
        return $count;
    }

    multi method consume(*%elems)
    {
        return %elems.map({ self.consume($_.key, $_.value) }).sum;
    }

    method log(Str $output)
    {
        say '  ' x $!verbose-indent, $output if $!verbose;
    }
}

multi sub MAIN(*@reactions, Int :$max-fuel = 1_000_000_000_000, Bool :v(:$verbose) = False)
{
    # Part 1
    my $factory = NanoFactory.new(:@reactions :$verbose);
    $factory.consume(:FUEL(1));
    my $ore-per-fuel-unit = $factory.ore-consumed;
    say "Total ORE consumption for 1 FUEL: $ore-per-fuel-unit";
    
    # Part 2
    # If k FUEL takes x ORE, then nk FUEL takes at most nx FUEL.
    # Use this to calculate the amount of fuel we can at least produce, and produce it.
    # Repeat until there's not enough ORE left for 1 FUEL.
    my $total-fuel = 1 + $factory.consume(:FUEL($factory.stock<FUEL>)); # leftover from part 1
    while (my $ore-remaining = $max-fuel - $factory.ore-consumed) ≥ $ore-per-fuel-unit {
        my $fuel = $ore-remaining div $ore-per-fuel-unit × $factory.output<FUEL>;
        $total-fuel += $factory.consume(:FUEL($fuel));
        say "Produced $fuel more FUEL, total $total-fuel." if $verbose;
    }
    say "FUEL produced for $max-fuel ORE: $total-fuel";
}

multi sub MAIN(Str $inputfile where *.IO.f, Int :$max-fuel = 1_000_000_000_000, Bool :v(:$verbose) = False)
{
    MAIN($inputfile.IO.lines, :$max-fuel, :$verbose);
}

multi sub MAIN(Int :$max-fuel = 1_000_000_000_000, Bool :v(:$verbose) = False)
{
    MAIN(~$*PROGRAM.sibling('aoc14.input'), :$max-fuel, :$verbose);
}
