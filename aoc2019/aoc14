#!/usr/bin/env perl6
use v6.d;

# Advent of Code 2019 day 14 -- https://adventofcode.com/2019/day/14

$*OUT.out-buffer = False;   # Autoflush

grammar Reaction
{
    rule TOP { [ <count-in> <elem-in> ]+ % ',' '=>' <count-out> <elem-out> }

    token count-in { \d+}
    token count-out { \d+}

    token elem-in { <alpha>+ }
    token elem-out { <alpha>+ }
}

class NanoFactory
{
    has Str @.reactions;
    has %.input;
    has %.output;

    has Bool $.verbose = False;
    has Int $!verbose-indent = 0;

    has Int %.stock is default(0);
    has Int $.ore-consumed = 0;

    submethod TWEAK
    {
        if !%!input && @!reactions {
            for @!reactions -> $r {
                my $ingredients = Reaction.parse($r) or die "Invalid reaction: $r";
                my $elem-out = ~$ingredients<elem-out>;
                my $count-out = +$ingredients<count-out>;
                for $ingredients<elem-in> Z $ingredients<count-in> -> ($e, $c) {
                    %!input{$elem-out}{$e} = +$c;
                    %!output{$elem-out} = $count-out;
                }
            }
        }
    }

    method reset
    {
        %!stock = Empty;
        $!ore-consumed = 0;
    }

    method produce(Str $elem, Int $count)
    {
        self.log("[Requested: $count $elem; stock is %!stock{$elem}]");

        my $to-produce = $count - %!stock{$elem};
        return if $to-produce ≤ 0;

        my $units = ceiling($to-produce / %!output{$elem});
        for %!input{$elem}.kv -> $e, $c {
            self.consume($e, $units × $c);
        }

        my $produced = $units × %!output{$elem};
        %!stock{$elem} += $produced;
        self.log("[Produced: $produced $elem; stock is %!stock{$elem}]");
    }

    method consume(Str $elem, Int $count)
    {
        $!verbose-indent++;
        if $elem eq 'ORE' {
            $!ore-consumed += $count;
            self.log("[Consumed: $count ORE; total ORE consumption is $!ore-consumed]");
        }
        else {
            self.produce($elem, $count);
            %!stock{$elem} -= $count;
            self.log("[Consumed $count $elem; stock is %!stock{$elem}]");
        }
        $!verbose-indent--;
    }

    method log(Str $output)
    {
        say '  ' x $!verbose-indent, $output if $!verbose;
    }
}

multi sub MAIN(*@reactions, Int :$max-fuel = 1_000_000_000_000, Bool :v(:$verbose) = False)
{
    # Part 1
    my $factory = NanoFactory.new(:@reactions :$verbose);
    $factory.produce('FUEL', 1);
    my $ore-for-one-fuel = $factory.ore-consumed;
    say "Total ORE consumption for 1 FUEL: $ore-for-one-fuel";
    
    # Part 2
    # If 1 FUEL takes x ORE, then n FUEL takes at most nx FUEL.
    # Use this to calculate the amount of fuel we can at least produce, and produce it.
    # Repeat until there's not enough ORE left for 1 FUEL.
    my $fuel-produced = 1;
    while (my $ore-remaining = $max-fuel - $factory.ore-consumed) ≥ $ore-for-one-fuel {
        $fuel-produced += $ore-remaining div $ore-for-one-fuel;
        $factory.produce('FUEL', $fuel-produced);
    }
    say "FUEL produced for $max-fuel ORE: $fuel-produced";
}

multi sub MAIN(Str $inputfile where *.IO.f, Int :$max-fuel = 1_000_000_000_000, Bool :v(:$verbose) = False)
{
    MAIN($inputfile.IO.lines, :$max-fuel, :$verbose);
}

multi sub MAIN(Int :$max-fuel = 1_000_000_000_000, Bool :v(:$verbose) = False)
{
    MAIN(~$*PROGRAM.sibling('aoc14.input'), :$max-fuel, :$verbose);
}
