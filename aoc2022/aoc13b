#!/usr/bin/env raku
use v6.d;
$*OUT.out-buffer = False;   # Autoflush

# Advent of Code 2022 day 13
# https://adventofcode.com/2022/day/13
# https://github.com/mscha/aoc

use JSON::Fast;

class Packet
{
    has Str $.spec;
    has $.data = from-json($!spec);
}

sub packet(Str $spec) { Packet.new(:$spec) }

multi sub compare(Packet $p, Packet $q, Bool :v(:$verbose) = False)
{
    return compare($p.data, $q.data, :$verbose);
}

multi sub compare($p, $q, Bool :v(:$verbose) = False)
{
    state $level = -1;
    temp $level; $level++;
    say '  ' x $level, $p, ' vs ', $q, ' ?' if $verbose;

    my $cmp = Same;
    if $p ~~ Int && $q ~~ Int {
        # Comparing two integers
        $cmp = $p <=> $q;
    }
    elsif ($p ~~ Int) {
        # Comparing an integer and a list - convert integer to list
        $cmp = compare([$p], $q, :$verbose);
    }
    elsif ($q ~~ Int) {
        # Comparing a list and an integer - convert integer to list
        $cmp = compare($p, [$q], :$verbose);
    }
    else {
        # Comparing two lists
        # Compare each item until we find one that's different
        for $p[] Z $q[] -> ($l, $r) {
            my $icmp = compare($l, $r, :$verbose);
            unless $icmp eq Same {
                $cmp = $icmp;
                last;
            }
        }
        # If all items are the same, compare the lengths of the lists
        $cmp ||= $p.elems <=> $q.elems;
    }

    say '  ' x $level, $p, ' vs ', $q, ': ', $cmp if $verbose;
    say '-' x 60 if $verbose && $level == 0;
    return $cmp;
}

sub MAIN(IO() $inputfile where *.f = 'aoc13.input', Bool :v(:$verbose) = False)
{
    my @packets = $inputfile.lines.grep(/\S/)».&packet;
    say 'Part 1: ', @packets.rotor(2)
                            .grep(-> ($p,$q) { compare($p,$q, :$verbose) eq Less }, :k)
                            .map(* + 1)    # Using 1-based indexing, sigh
                            .sum;

    my $dividers = set '[[2]]', '[[6]]';
    @packets.append(packet($_)) for $dividers.keys;
    @packets .= sort(&compare);
    say "Part 2: ", [×] @packets.grep(*.spec ∈ $dividers, :k).map(* + 1);
}
